#!/usr/bin/env python3
"""
Script to locate and store example messages for each unique template in production,
then create a separate Python file (mock_messages.py) containing a dictionary of
MOCK_MESSAGES that can be used to confirm no existing templates break after code changes.

Usage:
    1. Ensure your environment is set up correctly (project paths, credentials, etc.).
    2. Run the script in one of two ways:
       - With date argument: python generate_mock_template_messages.py --start-date 2025-01-03
       - Without date: python generate_mock_template_messages.py (will prompt for date)
    3. The script will search emails week by week (up to 10 weeks back) until it finds
       an example for each template type or hits the maximum iterations.
"""

import os
import sys
import json
import re
import logging
import argparse
import importlib.util
from typing import Dict, Any, List
from datetime import datetime, timedelta
from google.api_core import exceptions
import base64

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Add the project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

from src.utils.gmail_util import GmailUtil
from src.utils.transaction_parser import TransactionParser
from src.utils.credentials_manager import CredentialsManager

def get_all_template_names() -> List[str]:
    """Get all template names from TransactionParser"""
    parser = TransactionParser()
    return list(parser.TEMPLATES.keys())

def sanitize_for_python(raw_msg: Dict[str, Any]) -> Dict[str, Any]:
    """
    Sanitize a Gmail message for Python code output.
    Ensures all required fields are present and properly formatted.
    """
    # Extract key fields
    msg_id = raw_msg.get('id', '')
    thread_id = raw_msg.get('threadId', '')
    label_ids = raw_msg.get('labelIds', [])
    snippet = raw_msg.get('snippet', '')
    
    # Get the message body
    payload = raw_msg.get('payload', {})
    body = None
    
    def find_html_parts(payload):
        # results = []
        # If payload itself has 'parts', recurse:
        if 'parts' in payload:
            for p in payload['parts']:
                yield from find_html_parts(p)
        # Otherwise, if this part is text/html, yield it:
        elif payload.get('mimeType') == 'text/html':
            data = payload.get('body', {}).get('data', '')
            yield data
    body = list(find_html_parts(payload))
    
    # If no body found, use snippet
    if not body:
        body = base64.urlsafe_b64encode(snippet.encode()).decode()
    
    # Get headers
    headers = payload.get('headers', [])
    
    # Create sanitized message
    sanitized = {
        'id': msg_id,
        'threadId': thread_id,
        'labelIds': label_ids,
        'snippet': snippet,
        'payload': {
            'partId': '',
            'mimeType': 'text/html',
            'body': {
                'data': body
            },
            'headers': headers
        }
    }
    
    return sanitized

def write_mock_messages(found_templates: Dict[str, Any], output_dir: str):
    """Write found templates to mock_messages.py, preserving existing templates"""
    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    output_path = os.path.join(output_dir, 'mock_messages.py')
    existing_templates = {}
    
    # Try to load existing templates
    if os.path.exists(output_path):
        try:
            # Import the existing mock_messages module
            spec = importlib.util.spec_from_file_location("mock_messages", output_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            existing_templates = getattr(module, 'MOCK_MESSAGES', {})
            logger.info(f"Found {len(existing_templates)} existing templates")
        except Exception as e:
            logger.error(f"Error loading existing templates: {str(e)}")
    
    # Merge existing and new templates, preferring new ones
    merged_templates = {**existing_templates, **found_templates}
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('"""Mock Gmail messages for testing.\n')
        f.write('This file was auto-generated by generate_mock_template_messages.py\n')
        f.write('It contains example Gmail messages for each template found in production.\n')
        f.write('"""\n\n')
        
        f.write('MOCK_MESSAGES = {\n')
        
        for template_name, msg in merged_templates.items():
            # Convert message to formatted string
            msg_str = json.dumps(msg, indent=2)
            # Add template to dictionary
            f.write(f"  {repr(template_name)}: {msg_str},\n\n")
        
        f.write('}\n')
    
    # Log what changed
    new_templates = set(found_templates.keys()) - set(existing_templates.keys())
    if new_templates:
        logger.info(f"Added {len(new_templates)} new templates: {', '.join(new_templates)}")
    else:
        logger.info("No new templates added")

def write_mock_failures(found_failures: Dict[str, List[Dict[str, Any]]], output_dir: str):
    """Write failed template matches to mock_messages_failures.py, preserving existing failures"""
    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    output_path = os.path.join(output_dir, 'mock_messages_failures.py')
    existing_failures = {}
    
    # Try to load existing failures
    if os.path.exists(output_path):
        try:
            # Import the existing mock_messages_failures module
            spec = importlib.util.spec_from_file_location("mock_messages_failures", output_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            existing_failures = getattr(module, 'MOCK_FAILURES', {})
            logger.info(f"Found existing failures for {len(existing_failures)} users")
        except Exception as e:
            logger.error(f"Error loading existing failures: {str(e)}")
    
    # Merge existing and new failures, keeping max 2 per user
    merged_failures = existing_failures.copy()
    for email, failures in found_failures.items():
        if email not in merged_failures:
            merged_failures[email] = []
        
        # Add new failures up to max 2 per user
        existing_count = len(merged_failures[email])
        if existing_count < 2:
            space_left = 2 - existing_count
            merged_failures[email].extend(failures[:space_left])
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('"""Mock Gmail messages that failed template matching.\n')
        f.write('This file was auto-generated by generate_mock_template_messages.py\n')
        f.write('It contains up to 2 example failures per user.\n')
        f.write('"""\n\n')
        
        f.write('MOCK_FAILURES = {\n')
        
        for email, failures in merged_failures.items():
            # Convert failures to formatted string
            failures_str = json.dumps(failures, indent=2)
            # Add failures to dictionary
            f.write(f"  {repr(email)}: {failures_str},\n\n")
        
        f.write('}\n')
    
    # Log what changed
    new_users = set(found_failures.keys()) - set(existing_failures.keys())
    if new_users:
        logger.info(f"Added failures for new users: {', '.join(new_users)}")
    else:
        logger.info("No new failure examples added")

def parse_message(msg_id: str, service: Any) -> Dict[str, Any]:
    """Parse a message using TransactionParser"""
    parser = TransactionParser()
    
    try:
        # Get full message
        msg = service.users().messages().get(
            userId='me',
            id=msg_id,
            format='full'
        ).execute()
        
        # Parse with TransactionParser
        parsed_data = parser.parse_gmail_message(msg) or {}
        
        # Validate that this is a valid transaction
        if not parsed_data:
            return {}
            
        # Check that we have all required fields for a valid transaction
        required_fields = ['template_used', 'amount', 'vendor', 'account']
        if not all(field in parsed_data and parsed_data[field] for field in required_fields):
            return {}
            
        # Validate amount is numeric
        try:
            float(str(parsed_data['amount']).replace(',', ''))
        except (ValueError, TypeError):
            return {}
            
        # Validate account is a 4-digit number
        if not re.match(r'^\d{4}$', str(parsed_data['account'])):
            return {}
            
        return parsed_data
    except Exception as e:
        logger.error(f"Error parsing message {msg_id}: {str(e)}")
        return {}

def fetch_transaction_messages(service: Any, start_date: datetime, end_date: datetime) -> List[Dict[str, Any]]:
    """Fetch transaction messages within the date range"""
    # Build subject query parts - using case-insensitive matches
    subject_parts = [
        'subject:transaction',  # This will match both Transaction and transaction
        'subject:"External Transfer"',
        'subject:"Payment through Chase"',
        '(from:huntington subject:"withdrawal or purchase")',
        '(from:huntington subject:deposit -subject:"early pay")',
        '(subject:"account ending in" -from:noreply.pncalerts@pnc.com)'
    ]
    
    # Log each part of the query for debugging
    logger.info("Building query with parts:")
    for part in subject_parts:
        logger.info(f"  - {part}")
    
    # Combine with OR operator and exclude statements
    subject_query = f"({' OR '.join(subject_parts)})"
    
    # Combine with label filter and date range
    # Note: The label must be first in the query for better Gmail performance
    query = f'label:Transactions -subject:statement {subject_query} after:{start_date.strftime("%Y/%m/%d")} before:{end_date.strftime("%Y/%m/%d")}'
    
    # Log the full query in a more readable format
    logger.info("Final query:")
    logger.info("----------------------------------------")
    logger.info(query)
    logger.info("----------------------------------------")
    
    try:
        # Get message list
        results = service.users().messages().list(
            userId='me',
            q=query,
            maxResults=500  # Increased to ensure we find all templates
        ).execute()
        
        messages = results.get('messages', [])
        logger.info(f"Found {len(messages)} messages")
        return messages
    except Exception as e:
        logger.error(f"Error fetching messages: {str(e)}")
        return []

def main():
    """Main script execution"""
    parser = argparse.ArgumentParser(description='Generate mock template messages')
    parser.add_argument('--start-date', type=str, help='Start date in YYYY-MM-DD format')
    parser.add_argument('--email', type=str, help='Email account to check for templates', default='sdancy.10@gmail.com')
    args = parser.parse_args()
    
    # Get start date
    if args.start_date:
        try:
            start_date = datetime.strptime(args.start_date, '%Y-%m-%d')
        except ValueError:
            logger.error("Invalid date format. Please use YYYY-MM-DD")
            return
    else:
        start_date = datetime.now()
    
    # Initialize services
    try:
        from src.utils.config import Config
        config = Config()
        
        # Get user ID from config
        auth_config = config.get('auth', 'gmail')
        email_to_account = auth_config.get('email_to_account', {})
        accounts = auth_config.get('accounts', {})
        account_name = email_to_account.get(args.email)
        if not account_name:
            raise ValueError(f"Email {args.email} not found in config.yaml auth.gmail.email_to_account")
        account_config = accounts.get(account_name)
        if not account_config:
            raise ValueError(f"Account {account_name} not found in config.yaml auth.gmail.accounts")
        user_id = account_config.get('user_id')
        
        # Initialize credentials manager and get credentials
        creds_manager = CredentialsManager(config.get('project', 'id'), config)
        credentials = creds_manager.get_user_gmail_credentials(user_id, args.email)
        gmail_util = GmailUtil(credentials)
        service = gmail_util.service
    except Exception as e:
        logger.error(f"Failed to initialize services: {str(e)}")
        return
    
    # Get all template names
    all_templates = get_all_template_names()
    logger.info(f"Looking for examples of {len(all_templates)} templates")
    
    # Track found templates and failures
    found_templates = {}
    found_failures = {args.email: []}  # Initialize failures for current user
    
    # Track which email senders/subjects we've already found successful templates for
    successful_template_patterns = set()  # Will store tuples of (from_address, subject_pattern)
    
    # Try to find examples for each template
    current_start = start_date
    max_iterations = 10
    iteration = 0
    
    while iteration < max_iterations and len(found_templates) < len(all_templates):
        iteration += 1
        current_end = current_start + timedelta(days=7)
        
        logger.info(f"\nIteration {iteration}/{max_iterations}")
        logger.info(f"Checking period: {current_start.strftime('%Y-%m-%d')} to {current_end.strftime('%Y/%m/%d')}")
        logger.info(f"Found {len(found_templates)}/{len(all_templates)} templates")
        
        # Fetch messages for this period
        messages_info = fetch_transaction_messages(service, current_start, current_end)
        if not messages_info:
            logger.info("No messages found in this period")
            current_start = current_start - timedelta(days=7)
            continue
        
        # Process messages
        total_processed = 0
        for msg_info in messages_info:
            total_processed += 1
            if total_processed % 10 == 0:
                logger.info(f"Processed {total_processed}/{len(messages_info)} messages...")
                
            msg_id = msg_info["id"]
            try:
                raw_msg = service.users().messages().get(
                    userId='me', 
                    id=msg_id, 
                    format='full'
                ).execute()
                
                # Extract email metadata for pattern matching
                headers = {header['name']: header['value'] for header in raw_msg.get('payload', {}).get('headers', [])}
                from_address = headers.get('From', '')
                subject = headers.get('Subject', '')
                
                # Parse with TransactionParser
                parsed_data = parse_message(msg_id, service)
                template_name = parsed_data.get("template_used")
                
                sanitized_message = sanitize_for_python(raw_msg)
                
                # If template matched, add to found_templates and track the pattern
                if template_name and template_name not in found_templates:
                    logger.info(f"Found new template: {template_name}")
                    found_templates[template_name] = sanitized_message
                    successful_template_patterns.add((from_address, subject))
                
                # If no template matched and we have space for more failures
                # AND this email pattern isn't already associated with a successful template
                elif not template_name and len(found_failures[args.email]) < 2:
                    # Check if this email pattern matches any successful template patterns
                    is_known_template = False
                    for success_from, success_subject in successful_template_patterns:
                        if from_address == success_from:  # If from same sender, it's likely same template type
                            is_known_template = True
                            break
                    
                    if not is_known_template:
                        logger.info(f"Found new failure example for {args.email}")
                        found_failures[args.email].append(sanitized_message)
                
            except Exception as e:
                logger.error(f"Error fetching full message {msg_id}: {str(e)}")
                continue
        
        # Move back one week
        current_start = current_start - timedelta(days=7)
    
    # Write results
    output_dir = os.path.join(project_root, 'src', 'mock', 'api')
    
    if found_templates:
        write_mock_messages(found_templates, output_dir)
        logger.info(f"\nWrote {len(found_templates)} templates to mock_messages.py")
        logger.info("Missing templates: " + ", ".join(set(all_templates) - set(found_templates.keys())))
    else:
        logger.warning("No templates found!")
        
    if found_failures[args.email]:
        write_mock_failures(found_failures, output_dir)
        logger.info(f"\nWrote {len(found_failures[args.email])} failure examples for {args.email}")
    else:
        logger.info("No new failure examples found")

if __name__ == "__main__":
    main()

